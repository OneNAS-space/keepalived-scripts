#!/bin/sh

logger "Keepalived state changed: TYPE=$TYPE, NAME=$NAME, ACTION=$ACTION"

# --- natmap ---
natmap_installed=true
if ! command -v natmap >/dev/null 2>&1; then
	logger "natmap is not installed, skipping natmap control"
	natmap_installed=false
fi

start_natmap_if_needed() {
	local state_action=$1
	if service natmap status | grep -q "running"; then
		logger "natmap service is already running, skipping start"
	else
		logger "***** Starting natmap service *****"
		/etc/init.d/natmap enable
		/etc/init.d/natmap start 2>/dev/null || logger "Error starting natmap"
	fi
}

stop_natmap_if_needed() {
	local state_action=$1
	logger "***** Stopping natmap service *****"
	/etc/init.d/natmap stop 2>/dev/null || logger "Error stopping natmap"
	/etc/init.d/natmap disable
}

enable_natmap() {
	if [ "$natmap_installed" = true ]; then
		check_and_update "natmap.@global[0].enable" "1"
		start_natmap_if_needed "$ACTION"
	fi
}

disable_natmap() {
	if [ "$natmap_installed" = true ]; then
		check_and_update "natmap.@global[0].enable" "0"
		stop_natmap_if_needed "$ACTION"
	fi
}

# --- cloudflared ---
cloudflared_installed=true
if ! command -v cloudflared >/dev/null 2>&1; then
	logger "cloudflared is not installed, skipping cloudflared control"
	cloudflared_installed=false
fi

start_cloudflared_if_needed() {
	local state_action=$1
	if service cloudflared status | grep -q "running"; then
		logger "cloudflared service is already running, skipping start"
	else
		logger "***** Starting cloudflared service *****"
		/etc/init.d/cloudflared enable
		/etc/init.d/cloudflared start 2>/dev/null || logger "Error starting cloudflared"
	fi
}

stop_cloudflared_if_needed() {
	local state_action=$1
	logger "***** Stopping cloudflared service *****"
	/etc/init.d/cloudflared stop 2>/dev/null || logger "Error stopping cloudflared"
	/etc/init.d/cloudflared disable
}

enable_cloudflared() {
	if [ "$cloudflared_installed" = true ]; then
		check_and_update "cloudflared.config.enabled" "1"
		start_cloudflared_if_needed "$ACTION"
	fi
}

disable_cloudflared() {
	if [ "$cloudflared_installed" = true ]; then
		check_and_update "cloudflared.config.enabled" "0"
		stop_cloudflared_if_needed "$ACTION"
	fi
}

# --- Check and update UCI settings ---
check_and_update() {
	local config_key=$1
	local target_value=$2
	local current_value
	current_value=$(uci get "$config_key" 2>/dev/null)

	if [ "$current_value" != "$target_value" ]; then
		logger "Updating $config_key from $current_value to $target_value"
		uci set "$config_key"="$target_value"
		uci commit "${config_key%%.*}" 2>/dev/null || logger "Error committing config"
		else
		logger "$config_key is already set to $target_value, skipping"
	fi
}

# --- DHCPv4 option ---
enable_dhcpv4_add_option() {
	local VIP
	VIP=$(/etc/keepalived/scripts/get_lan_vip.sh)
	if [ $? -ne 0 ] || [ -z "$VIP" ]; then
		logger "FATAL ERROR: Failed to get VIP from external script. Cannot configure DHCP. Exiting."
		exit 1
	fi
	logger "VIP initialization successful inside function: VIP=$VIP"

	uci batch <<-EOF
		delete dhcp.lan.ignore
		delete dhcp.lan.dhcp_option
		add_list dhcp.lan.dhcp_option='3,$VIP'
		add_list dhcp.lan.dhcp_option='6,$VIP'
		commit dhcp.lan
	EOF
	logger "*** Enable DHCPv4 and DHCP option ***"
}

disable_dhcpv4_clear_option() {
	uci batch <<-EOF
		set dhcp.lan.ignore=1
		delete dhcp.lan.dhcp_option
		commit dhcp.lan
	EOF
	logger "*** Cleared DHCP option ***"
}

# --- DHCP RA flags ---
add_dhcpv6_ra_flags() {
	uci batch <<-EOF
		delete dhcp.lan.ra_flags
		add_list dhcp.lan.ra_flags=managed-config
		add_list dhcp.lan.ra_flags=other-config
		add_list dhcp.lan.ra_flags=home-agent
		commit dhcp.lan
	EOF
	logger "*** Setting DHCP RA flags ***"
}

clear_dhcpv6_ra_flags() {
	uci batch <<-EOF
		delete dhcp.lan.ra_flags
		commit dhcp.lan
	EOF
	logger "*** Cleared DHCP RA flags ***"
}

# --- Restart dnsmasq if necessary ---
restart_dnsmasq_if_needed() {
	local state_action=$1
	logger "***** Restarting dnsmasq service *****"
	/etc/init.d/dnsmasq restart 2>/dev/null || logger "Error restarting dnsmasq"
}

# --- Restart odhcpd if necessary ---
restart_odhcpd_if_needed() {
	local state_action=$1
	logger "***** Restarting odhcpd service *****"
	/etc/init.d/odhcpd restart 2>/dev/null || logger "Error restarting odhcpd"
}

# --- Check if keepalived is shutting down ---
if [ "$ACTION" = "shutdown" ]; then
	clear_dhcpv6_ra_flags "$ACTION"
	disable_cloudflared "$ACTION"
	disable_natmap "$ACTION"
	logger "*** Keepalived is shutting down, removing state files ***"
	rm -f /tmp/keepalived_initial_start
	exit 0
fi

# --- Check if keepalived is starting up ---
if [ "$ACTION" = "startup" ]; then
	logger "***** Keepalived is starting, marking initial start *****"
	touch /tmp/keepalived_initial_start
	exit 0
fi

# --- Only handle GROUP events to avoid duplicate triggers ---
if [ "$TYPE" != "GROUP" ]; then
	exit 0
fi

if [ "$TYPE" = "GROUP" ]; then
	case "$ACTION" in
		NOTIFY_MASTER)
			echo "MASTER" > /tmp/keepalived_state
			;;
		NOTIFY_BACKUP)
			echo "BACKUP" > /tmp/keepalived_state
			;;
	esac
fi

# --- Set the scheduled task on the Master host, and remove it on the Backup host. ---
schedule_sync_leases() {
	if [ "$1" = "NOTIFY_MASTER" ]; then
		logger "MASTER: Starting Procd lease sync service (Silent Mode)"
		/etc/init.d/lease_sync enable
		/etc/init.d/lease_sync start
	elif [ "$1" = "NOTIFY_BACKUP" ] || [ "$1" = "NOTIFY_FAULT" ]; then
		logger "BACKUP/FAULT: Stopping Procd lease sync service"
		/etc/init.d/lease_sync stop
		/etc/init.d/lease_sync disable
	fi
}

# --- Handle delayed execution for NOTIFY_BACKUP after startup ---
if [ -f /tmp/keepalived_initial_start ] && [ "$ACTION" = "NOTIFY_BACKUP" ]; then
	logger "*** Detected initial NOTIFY_BACKUP after Keepalived start, delaying execution ***"
	sleep 5

	CURRENT_STATE=$(cat /tmp/keepalived_state)
	rm -f /tmp/keepalived_initial_start

	if [ "$CURRENT_STATE" = "BACKUP" ]; then
		logger "*** After delay, Keepalived is still in BACKUP state, executing NOTIFY_BACKUP logic ***"
		enable_cloudflared "$ACTION"
		disable_dhcpv4_clear_option "$ACTION"
		restart_dnsmasq_if_needed "$ACTION"

		check_and_update "dhcp.lan.dhcpv6" "disabled"
		check_and_update "dhcp.lan.ra" "disabled"
		clear_dhcpv6_ra_flags "$ACTION"
		restart_odhcpd_if_needed "$ACTION"

		schedule_sync_leases "$ACTION"
		disable_natmap "$ACTION"
	else
		logger "*** After delay, Keepalived is no longer in BACKUP state, skipping NOTIFY_BACKUP execution ***"
		exit 0
	fi
fi

# --- The Master host will actively synchronize the leases file to the Backup host (or pull it from the Backup) ---
master_initiates_sync() {
	local sync_direction=$1
	local peer_ip=$(/etc/keepalived/scripts/sync_leases.sh get_peer_ip)

	if [ -z "$peer_ip" ]; then
		logger "master_initiates_sync: Error: Could not determine peer LAN IP, skipping sync."
		return 1
	fi

	# New logic: When Master starts, try to pull it from the other end first.
	if [ "$sync_direction" = "PULL_ON_MASTER_START" ]; then
		logger "Executing sync_leases.sh to pull DHCP leases from peer ($peer_ip) in MASTER startup"
		# Try to pull it from the other end. If the other end exists and is active
		/etc/keepalived/scripts/sync_leases.sh pull "$peer_ip" &
	elif [ "$sync_direction" = "NOTIFY_MASTER" ]; then
		logger "Executing sync_leases.sh to push DHCP leases to peer ($peer_ip) in MASTER state"
		# MASTER PUSH
		/etc/keepalived/scripts/sync_leases.sh push "$peer_ip" &
	fi
}

# --- Process Keepalived state directly from the ACTION ---
if [ "$ACTION" = "NOTIFY_MASTER" ]; then
	logger "Keepalived state is MASTER, enabling services"

	# Priority: Try to pull the lease file from the other end when Master starts.
	# This step should be completed before dnsmasq starts to ensure that it can be loaded into the latest lease.
	master_initiates_sync "PULL_ON_MASTER_START"
	sleep 1

	enable_dhcpv4_add_option "$ACTION"
	restart_dnsmasq_if_needed "$ACTION"
	enable_natmap "$ACTION"
 	schedule_sync_leases "$ACTION"

	check_and_update "dhcp.lan.dhcpv6" "server"
	check_and_update "dhcp.lan.ra" "server"
	add_dhcpv6_ra_flags "$ACTION"
	restart_odhcpd_if_needed "$ACTION"

	disable_cloudflared "$ACTION"
elif [ "$ACTION" = "NOTIFY_BACKUP" ]; then
	logger "Keepalived state is BACKUP, disabling services"

	enable_cloudflared "$ACTION"
	disable_dhcpv4_clear_option "$ACTION"
	restart_dnsmasq_if_needed "$ACTION"

	check_and_update "dhcp.lan.dhcpv6" "disabled"
	check_and_update "dhcp.lan.ra" "disabled"
	clear_dhcpv6_ra_flags "$ACTION"
	restart_odhcpd_if_needed "$ACTION"

	disable_natmap "$ACTION"
	schedule_sync_leases "$ACTION"
elif [ "$ACTION" = "NOTIFY_FAULT" ]; then
	logger "Keepalived state is FAULT, disabling services"

	disable_natmap "$ACTION"
	disable_cloudflared "$ACTION"
	schedule_sync_leases "$ACTION"
fi
